<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      // 반복문 (for, while, for in, for of)
      // for (초기식; 조건식; 증감식) { ... }
      for (let i = 0; i < 3; i++) {
        console.log("for 반복 :", i);
        console.log(`for 반복 : ${i}`);
      }
      //   for (;;) {
      //     console.log("무한한 저 너머로~");
      //   } // 무한루프
      let count = 0;
      while (count < 10) {
        console.log("while 반복 :", count);
        count++;
      } // block {} -> 세미콜론 X.
      // continue, break 같은 역할을 함.

      // JS 배열 -> java 타입[] = {}
      // JS [] => 리스트. 길이 제한 X. 타입도 달라도 된다. 파이썬 리스트와 유사.
      // 배열 자체를 다시 재정의하는 경우는 없고, 내부를 교체하는 개념
      const arr = [];
      //   let : 재할당 -> arr <= ...
      // 배열은 추가, 삭제, 조회, 수정... -> 아예 새로 할당하는 경우가 없음. 메모리상의 이점. const 저장하면 메모리상 이점.
      // 배열 push.
      arr.push(1); // 맨 끝에 추가 push.
      arr.push("일");
      arr.push(true);
      console.log(arr);
      // 맨 끝에서 제거할 때 pop.
      console.log(arr.pop());
      console.log(arr[0]); // 0부터 시작 인덱스...
      console.log(arr[1]);
      console.log(arr);
      console.log(arr[2]);
      // &&, || -> 단축연산. Java -> True, False로 평가하여, 그 다음에 단축연산...
      console.log(arr[1] || "기본값");
      console.log(arr[2] || "기본값");
      console.log(arr.length); // length
      // 배열 .length, 문자열 .length()
      // 리스트 .size() ...
      const arr2 = [1, 2, 3, 4, 5];
      console.log(arr2);
      //   arr2.length = 0;
      //   console.log(arr2);
      //   arr2.length = 10;
      //   console.log(arr2);
      //   console.log(arr2[0]);

      // 향상된 for문.
      // for (타입 v : 배열이나 리스트 lst) {}
      // 순회, 검색...
      for (const v of arr2) {
        console.log("for ... of:", v);
      }
      const arr3 = ["사과", "바나나", "키위"];
      for (let i = 0; i < 3; i++) {
        console.log(arr3[i]);
      }
      // 전체 값 확인
      for (const item of arr3) {
        console.log(item);
      }
      // 실제로 원리는 뭐냐? 인덱스를 불러오는 건가?
      // 키. -> 배열의 경우엔 인덱스가 키.
      for (const index in arr3) {
        console.log(index, arr3[index]);
      }
      const obj = {
        // 키 : 값.
        name: "변영인",
        job: "프로그래머",
      };
      for (const key in obj) {
        console.log(key, obj[key]);
      }
      // 자바스크립트도 정확히는 인덱스가 아니라 키라는 의미.
      arr3[5] = "딸기";
      console.log(arr3);
      arr3[0.5] = "배";
      console.log(arr3);
      arr3["맛"] = "달다";
      console.log(arr3);
      // 파이썬 마이너스 인덱스 -> 뒤로부터...
      console.log(arr3[-1]);
      arr3[-1] = "ㅎㅎㅎ";
      console.log(arr3);

      // 예외처리
      // try catch finally
      // finally -> return -> return 덮어씌울만큼...
      // throws -> 상위가 알아서 처리해줘?
      // 메서드 시그니쳐에 Exception 넣기 X
      // catch (e) <- 타입지정, 감지.
      try {
        // console.log(1 / 0); // 에러가 아님;;;
        JSON.parse("{...}");
      } catch {
        // e (에러 객체)
        console.error("에러~");
      }

      try {
        // console.log(1 / 0); // 에러가 아님;;;
        // JSON.parse("{...}");
        let obj;
        console.log(obj.name);
      } catch (e) {
        // 타입을 입력해줄 필요X
        console.error("에러 메시지", e.message);
        console.error("에러 타입 : object", typeof e);
        console.error("에러 클래스 이름", e.constructor.name);
        console.log("e instanceof SyntaxError", e instanceof SyntaxError);
        console.log("e instanceof TypeError", e instanceof TypeError);
        if (e instanceof SyntaxError) {
          console.log("Syntax 에러입니다!");
        }
        if (e instanceof TypeError) {
          console.log("Type 에러입니다!");
        }
      }

      try {
        // Error!
        throw new Error("내가 만든 에러, 너를 위해 작성했지");
      } catch (err) {
        console.log(err.message);
      }
    </script>
  </body>
</html>
